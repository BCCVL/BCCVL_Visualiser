<!DOCTYPE html>
<html style="width:100%; height:100%">
    <head>
        <title>Multiple Raster Layers</title>
        <script src="//maps.google.com/maps/api/js?v=3&amp;sensor=false"></script>
        <script src="${request.static_url('bccvl_visualiser:static/js/OpenLayers.js')}"></script>
        <script src="${request.static_url('bccvl_visualiser:static/js/LoadingPanel.js')}"></script>

        <script defer="defer" type="text/javascript">

            var map, mercator, geographic;
            var loading_pannel;

            function init() {
                // DecLat, DecLng 
                geographic = new OpenLayers.Projection("EPSG:4326");

                // Spherical Meters
                // The official name for the 900913 (google) projection
                mercator = new OpenLayers.Projection("EPSG:3857");

                // Australia Bounds
                australia_bounds = new OpenLayers.Bounds();
                australia_bounds.extend(new OpenLayers.LonLat(111,-10));
                australia_bounds.extend(new OpenLayers.LonLat(152,-44));
                australia_bounds = australia_bounds.transform(geographic, mercator);

                var zoom_bounds = australia_bounds;               

                map = new OpenLayers.Map('map', {
                    projection: mercator,
                    eventListeners: {
                        "changelayer": mapLayerChanged
                    }
                })

                loading_pannel = new OpenLayers.Control.LoadingPanel();
                map.addControl(loading_pannel);

                // get the list of raster urls
                var data = "${raster_list}";
                var rasterList = data.split(',')
                var myLayers = [];


                /* FUNCTIONS FOR CREATING COLOR SPECTRUMS AND CONSTRUCTING XML SLD DOCUMENTS TO PASS TO MAP TILE REQUESTS */

                /*  Goal here is to determine minimum and maximum raster values in the map layer, 
                    dividing it by an arbitrary number of levels.  This is then used to make an array
                    of thresholds for color values to be associated with.  
                */

                /*  Important to note here that due to the structure of an SLD doc, the number of
                    threshold values must always be one more than the number of desired color levels.
                    The number of color values must then be one greater than the thresholds.
                    SLD requests are packed like: Color-Threshold-*colorlevel*-Color...., so the end 
                    result will always have +1 threshold and +2 color values on top of your desired number of colour values.
                */


                // dummy max and min values, eventually replaced with relative-to-layer values
                var minVal = 0;
                var maxVal = 100;
                var steps = 20;
                
                var rangeInt = (maxVal - minVal)/steps;
                var rangeArr = [];
                for (var i = 0; i < (steps+1); i++) {
                    rangeArr.push((rangeInt*i).toFixed(2));
                }

                /*  Generate array of hexidecimal colour values, note the extra value on top of threshold range. */

                // utility functions to convert RGB values into hex values for SLD styling.
                function byte2Hex(n) {
                    var nybHexString = "0123456789ABCDEF";
                    return String(nybHexString.substr((n >> 4) & 0x0F,1)) + nybHexString.substr(n & 0x0F,1);
                }
                function RGB2Color(r,g,b) {
                    return '#' + byte2Hex(r) + byte2Hex(g) + byte2Hex(b);
                }

                // White to blue spectrum
                // 30, 77, 155 endpoint
                var startpoint = {};
                    startpoint.r = 255;
                    startpoint.g = 255;
                    startpoint.b = 255;
                var endpoint = {};
                    endpoint.r = 30;
                    endpoint.g = 77;
                    endpoint.b = 155;

                var colorArr = [];
                for (var i = 0; i < (steps+2); i++) {
                    // red
                    var redInt = (startpoint.r - endpoint.r)/steps;
                    var redVal = startpoint.r - (redInt*i);
                    // green
                    var greenInt = (startpoint.g - endpoint.g)/steps;
                    var greenVal = startpoint.g - (greenInt*i);
                    // blue
                    var blueInt = (startpoint.b - endpoint.b)/steps;
                    var blueVal = startpoint.b - (blueInt*i);

                    colorArr.push(RGB2Color(redVal,greenVal,blueVal));
                }

                var xmlStylesheet = '<StyledLayerDescriptor version="1.1.0" xsi:schemaLocation="http://www.opengis.net/sld http://schemas.opengis.net/sld/1.1.0/StyledLayerDescriptor.xsd" xmlns="http://www.opengis.net/sld" xmlns:ogc="http://www.opengis.net/ogc" xmlns:se="http://www.opengis.net/se" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><NamedLayer><se:Name>DEFAULT</se:Name><UserStyle><se:Name>xxx</se:Name><se:FeatureTypeStyle><se:Rule><se:RasterSymbolizer><se:Opacity>0.7</se:Opacity><se:ColorMap><se:Categorize fallbackValue="#78c818"><se:LookupValue>Rasterdata</se:LookupValue>';

                for (var i = 0; i < (steps+1); i++) {
                    xmlStylesheet += '<se:Value>'+colorArr[i]+'</se:Value><se:Threshold>'+rangeArr[i]+'</se:Threshold>';
                }

                xmlStylesheet += '<se:Value>'+colorArr[colorArr.length-1]+'</se:Value>';

                xmlStylesheet += '</se:Categorize></se:ColorMap></se:RasterSymbolizer></se:Rule></se:FeatureTypeStyle></UserStyle></NamedLayer></StyledLayerDescriptor>';

                /* END SLD GENERATION */






                // WMS Layers from the list
                rasterList.forEach(function(raster){
                    if (raster != '') {
                        // get the filename
                        var url_terms = raster.split('/');
                        var filename = url_terms[url_terms.length -1]
                        var wms = new OpenLayers.Layer.WMS(
                            filename,
                            './wms_data_url',
                            {  
                                transparent: "true",
                                format: "image/png",
                                DATA_URL: raster,
                                SLD_BODY: xmlStylesheet
                            },
                            {
                                isBaseLayer: false,
                                visibility: false
                            }
                        );
                        myLayers.push(wms)
                    }
                })

                var osm = new OpenLayers.Layer.OSM();
                var gmap = new OpenLayers.Layer.Google("Google Streets", {visibility: false});
                myLayers.push(osm, gmap)

                var ls = new OpenLayers.Control.LayerSwitcher();
                map.addLayers(myLayers)
                map.addControl(ls);
                map.zoomToExtent(zoom_bounds);

                // Make the layer switcher open by default
                ls.maximizeControl();
                
                // eventListener which only allows one overlay to displayed at a time
                function mapLayerChanged(event) {
                    ls.dataLayers.forEach(function(dataLayer) {
                        if (dataLayer.layer.name == event.layer.name && event.layer.visibility) {
                            dataLayer.layer.visibility = true;
                            dataLayer.layer.display(true);
                        }     
                        else {
                            dataLayer.layer.visibility = false;
                            dataLayer.layer.display(false);
                        }
                    })
                }
  
                //TODO: Figure out what to do with the legend
                // Add the legend image
                // var data_url_escaped = encodeURIComponent("${raster_list[16]}");
                // var legend_img_src = "./wms_data_url?REQUEST=GetLegendGraphic&VERSION=1.0.0&FORMAT=image/png&WIDTH=60&HEIGHT=60&DATA_URL=" + data_url_escaped + "&BBOX=-180,-90,180,90&SRS=EPSG%3A4326";
                // // Update legend image src
                // document.getElementById("legend").src = legend_img_src;
            }
        </script>

    </head>
    <body style="width:100%; height:100%; margin: 0;" onload="init()">
        <!-- <img alt="Map Legend" style="opacity: 1.0; position: absolute; bottom: 10px; left:10px; z-index: 100000;" id="legend"></img> -->
        <div style="width:100%; height:100%" id="map"></div>
        <div class="overlay" id="loading-overlay"></div>
    </body>
</html>
